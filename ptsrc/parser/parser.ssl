%  PT Parser.ssl        v1.02
%
% Date:  30 Jun 1980
%        (Revised 19 December 2017)
%
% Author:  Alan Rosselet
%
% Abstract
%
%     This module parses the syntax token stream emitted by the scanner
%   and emits a postfix stream of tokens to the semantic analyzer
%   module.  The parser detects and repairs syntax errors so that the
%   token stream emitted to the semantic analyzer is syntactically
%   legal (except for the special case of declaration phase errors - see
%   comment in the Block routine below).

Input :
        % Keywords must be first both here and in stdIdentifiers,
        % and they must appear in the same order

        pDiv                    'div'
        firstKeywordToken = pDiv
        pMod                    'mod'
        pOr                     'or'
        pAnd                    'and'
        pNot                    'not'
        pElse                   'else'
        pOf                     'of'
        pEnd                    'end'
        pArray                  'array'
        pFile                   'file'
        pPacked                 'packed'
        pVar                    'var'
        pIf                     'if'
        pExt                    'ext'  % Removed old PT keywords and added keywords seen on lines 35-45
        pCon                    'con'
        pTyp                    'typ'
        pDef                    'def'
        pPub                    'pub'
        pElif                   'elif'
        pSel                    'sel'
        pIs                     'is'
        pOn                     'on'
        pBreak                  'break'
        pLen                    'len'        
        pRep                    'rep'
        lastKeywordToken = pRep 

        pIdentifier 
        firstCompoundInputToken = pIdentifier
        pInteger
        pLiteral
        lastCompoundInputToken = pLiteral

        pNewLine
        pEndFile
        pPlus                   '+'
        pMinus                  '-'
        pStar                   '*'
        pPlusEquals             '+='  % Added Quby plus equals token and remove colon equals := token.
        pMinusEquals            '-='  % Added Quby minus equals token
        pDoubleEquals           '=='  % Added Quby double equals token
        pLeftBrace              '{'   % Added Quby left brace token
        pRightBrace             '}'   % Added Quby right brace token
        pDot                    '.'
        pComma                  ','
        pSemicolon              ';'
        pColon                  ':'
        pEquals                 '='
        pNotEqual               '!='
        pLess                   '<'
        pLessEqual              '<='
        pGreaterEqual           '>='
        pGreater                '>'
        pLeftParen              '('
        pRightParen             ')'
        pLeftBracket            '['
        pRightBracket           ']'
        pBang                   '#'   % Added Quby non-compound bang token
        pDotDot                 '..'
        lastSyntaxToken = pDotDot;

Output :
        sIdentifier 
        firstSemanticToken = sIdentifier
        firstCompoundSemanticToken = sIdentifier
        sInteger
        sLiteral
        lastCompoundSemanticToken = sLiteral

        sProgram
        sParmBegin
        sParmEnd
        sConst
        sType
        sVar
        sProcedure
        sBegin
        sEnd
        sNegate
        sArray
        sPacked
        sFile
        sRange
        sSelStmt   % Changed from sCaseStmt to sSelStmt for Quby select statements
        sSelEnd    % Changed from sCaseEnd to sSelEnd
        sLabelEnd
        sExpnEnd
        sNullStmt
        sAssignmentStmt
        sSubscript
        sCallStmt
        sFieldWidth
        sIfStmt
        sThen
        sElse
        sRepStmt   % Added sRepStmt and sRepOnBreak, removed PT sWhileStmt, sRepeatStmt, and sRepeatEnd
        sRepOnBreak
        sEq
        sNE
        sLT
        sLE
        sGT
        sGE
        sAdd
        sSubtract
        sMultiply
        sDivide
        sModulus
        sInfixOr
        sOr
        sInfixAnd
        sAnd
        sNot
        sModule    % Added Quby sModule and sPublic for Quby modules
        sPublic 
        sSubstring % Added sSubstring and sLen for Quby string operations
        sLen
        sNewLine
        sEndOfFile
        lastSemanticToken = sEndOfFile;


rules

Program :
        'ext'  .sProgram % Quby programs begin with 'ext' not 'program', and do not have a program name, only parameters.
        % program parameters
        {
            pIdentifier  .sIdentifier
            [
                | ',':
                | *:
                    >
            ]
        }
        .sParmEnd
        @Block; % Quby has no semicolons and does not use periods after end of program. 

Block :
        % Strictly speaking, standard Pascal requires that declarations
        % appear only in the order consts, types, vars, procedures.
        % We allow arbitrary intermixing of these instead to preserve
        % programmer sanity.
        {[
            | 'con':
                .sConst
                @ConstantDefinitions
            | 'typ':
                .sType
                @TypeDefinitions
            | 'var':
                .sVar
                @VariableDeclarations
            | 'mod':                      % Add in handling of Quby Modules
                .sModule % module name
                pIdentifier .sIdentifier
                @Block  % Remember modules can contain declarations and statements blocks just like a regular code block.
                'end'
            | 'def':
                .sProcedure
                % procedure name
                [
                    | 'pub':
                        .sPublic
                    | *:
                ]
                pIdentifier  .sIdentifier
                @ProcedureHeading
                @Block
                'end'
            | *:
                >
        ]}
        % Quby no longer uses 'begin' at beginning of procedures
        @BeginStmt;

ConstantDefinitions :
        % Accept one or more named constant definitions
        pIdentifier  .sIdentifier
        @ConstantValue;  % Remove ability to have multiple constant type declaration with only one keyword. Quby require 'con' keyword to be repeated for each declaration.

ConstantValue :
        '='
        [
            | pInteger:
                .sInteger
            | pIdentifier:
                .sIdentifier
            | '-':
                @UnsignedIntegerConstant
                .sNegate
            | '+':
                @UnsignedIntegerConstant
            | pLiteral:
                .sLiteral
        ];

UnsignedIntegerConstant :
        [
            | pIdentifier:
                .sIdentifier
            | pInteger:
                .sInteger
        ];

TypeDefinitions :
        % Accept one or more named type definitions.
        pIdentifier  .sIdentifier
        ':'  @TypeBody % Look for colon, and no longer expect semicolon
        ; % Remove ability to have multiple declarations under one 'typ' keyword

TypeBody :
        [
            | 'packed':
                'array'  .sArray  .sPacked
                '['  @SimpleType  ']'
                'of'  @SimpleType
            | 'array':
                .sArray
                '['  @SimpleType  ']'
                'of'  @SimpleType
            | 'file':
                .sFile
                'of'  @SimpleType
            | *:
                @SimpleType
        ];

SimpleType :
        % A simple type is a named type (possibly predefined)
        % or a subrange type specification
        [
            | pIdentifier:
                .sIdentifier
                [
                    | '..':
                        .sRange         %% this may be unnecessary
                        @OptionallySignedIntegerConstant
                    | *:
                ]
            | *:
                @OptionallySignedIntegerConstant
                '..'  .sRange
                @OptionallySignedIntegerConstant
        ];

OptionallySignedIntegerConstant :
        [
            | '-':
                @UnsignedIntegerConstant
                .sNegate
            | '+':
                @UnsignedIntegerConstant
            | *:
                @UnsignedIntegerConstant
        ];

VariableDeclarations :
        % Accept one or more variable declarations.
        pIdentifier  .sIdentifier
        ':'  @TypeBody  % don't expect semicolon
        ; % Remove ability to have multiple var declarations after each other         

ProcedureHeading :
        % Accept zero or more procedure formal parameter declarations.
        [
            | '(':
                {
                    % formal parameter identifier
                    [
                        | 'var':
                            pIdentifier  .sIdentifier
                            .sVar
                        | *:
                            pIdentifier  .sIdentifier
                    ]
                    ':'
                    % type identifier
                    pIdentifier  .sIdentifier
                    [
                        | ',':
                        | *:
                            >
                    ]
                }
                ')'
            | *:
        ]
        .sParmEnd;

Statement :
        [
             | pIdentifier:
                 @AssignmentOrCallStmt
             | 'if':
                 @IfStmt
%            | 'while':
%                @WhileStmt
%            | 'case':
%                @CaseStmt
%            | 'repeat':
%                @RepeatStmt
             | *:
                .sNullStmt
        ];

AssignmentOrCallStmt :
        [
            | '=':
                .sAssignmentStmt
                .sIdentifier    % identifier accepted in the Statement rule
                @Expression
                .sExpnEnd
            | '[':
                .sAssignmentStmt
                .sIdentifier
                .sSubscript
                @Expression
                .sExpnEnd
%                ']'  ':='
                @Expression
                .sExpnEnd
            | *:
                @CallStmt
        ];

CallStmt :
        .sCallStmt
        .sIdentifier    % procedure identifier accepted in the Statement rule
        % accept zero or more actual parameters
        [
            | '(':
                {
                    @Expression
                    .sExpnEnd
                    % allow a field width specification to occur in calls
                    % to the standard procedures write and writeln
                    [
                        | ':':
                            .sFieldWidth
                            @Expression
                            .sExpnEnd
                        | *:
                    ]
                    [
                        | ',':
                        | *:
                            >
                    ]
                }
                ')'
            | *:        % no actual parameters
        ]
        .sParmEnd;

BeginStmt :
        .sBegin
        {
            @Statement % In Quby declarations and statements are seperate, so after all the statements are complete the program should end.
            [
                  | pNewLine:
                  | *:
                       >
            ]
        }
        .sEnd;

IfStmt :
        .sIfStmt
        @Expression
        .sExpnEnd
        .sThen
        ':'
        @BeginStmt
        [
            | 'else':
                .sElse
                ':'
                @BeginStmt
                'end'
            | 'elif':
                .sElse
                .sBegin
                @IfStmt
                .sEnd
            | 'end':
            | *:
        ];

%CaseStmt :
%        .sCaseStmt
%        @Expression
%        .sExpnEnd
%        'of'
%        @CaseAlternative
%        {[
%            | ';':
%                % since case alternatives cannot be null, allow
%                % for the common situation of an extra semicolon
%                % at the end of the list of case alternatives.
%                [
%                    | 'end':
%                        >
%                    | *:
%                       @CaseAlternative
%                ]
%            | 'end':
%                >
%        ]}
%        .sCaseEnd;

CaseAlternative :
        % A case alternative is a statement labelled by
        % one or more optionally signed integer constants

        {
            @OptionallySignedIntegerConstant
            [
                | ',':
                | *:
                    >
            ]
        }
        .sLabelEnd
        ':'  @Statement;

%WhileStmt :
%        .sWhileStmt
%        @Expression
%        .sExpnEnd
%        'do'
%        @Statement;

%RepeatStmt :
%        .sRepeatStmt
%        {
%            @Statement
%            [
%                | ';':
%                | 'until':
%                    .sRepeatEnd
%                    >
%            ]
%        }
%        @Expression
%        .sExpnEnd;

Expression :
        @SimpleExpression
        [
            | '==':
                @SimpleExpression  .sEq
            | '!=':
                @SimpleExpression  .sNE
            | '<':
                @SimpleExpression  .sLT
            | '<=':
                @SimpleExpression  .sLE
            | '>':
                @SimpleExpression  .sGT
            | '>=':
                @SimpleExpression  .sGE
            | *:
        ];

SimpleExpression :
        [
            | '+':
                @Term
            | '-':
                @Term  .sNegate
            | *:
                @Term
        ]
        {[
            | '+':
                @Term  .sAdd
            | '-':
                @Term  .sSubtract
            | 'or':
                .sInfixOr  @Term  .sOr
            | *:
                >
        ]};

Term :
        @Factor
        {[
            | '*':
                @Factor  .sMultiply
            | 'div':
                @Factor  .sDivide
            | 'mod':
                @Factor  .sModulus
            | 'and':
                .sInfixAnd  @Factor  .sAnd
            | *:
                >
        ]};

Factor :
        [
            | pIdentifier:
                .sIdentifier
                @IdentifierExtension
            | pInteger:
                .sInteger
            | '(':
                @Expression  ')'
            | 'not':
                @Factor
                .sNot
            | pLiteral:
                .sLiteral
            | 'file':
                .sFile '(' @Expression ')'
                .sExpnEnd
        ];

IdentifierExtension :
        % Handle subscripts and function actual parameter lists
        [
            | '[':
                .sSubscript
                @Expression  ']'
                .sExpnEnd
            | '(':
                .sParmBegin
                @Expression  ')'
                .sExpnEnd
                .sParmEnd
            | *:
        ];

end
